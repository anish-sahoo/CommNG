-- Wrap everything in a single transaction so we either apply all changes or none.
BEGIN;

-- Define PostgreSQL ENUM types for constrained string values.
-- Using ENUMs makes allowed values explicit and prevents typos in data.
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'permission_enum') THEN
        CREATE TYPE permission_enum AS ENUM ('read','write','both');
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'mentor_status_enum') THEN
        CREATE TYPE mentor_status_enum AS ENUM ('requested','approved','active');
    END IF;
END$$;

-- USERS: people using the system. We store contact details and metadata.
-- We use "GENERATED BY DEFAULT AS IDENTITY" (modern replacement for SERIAL)
-- so PostgreSQL manages auto-incrementing IDs.
CREATE TABLE IF NOT EXISTS users (
    user_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    email TEXT UNIQUE NOT NULL,
    phone_number TEXT,
    clearance_level TEXT,
    department TEXT,
    branch TEXT, -- e.g. 'Air Force', 'Army', 'Common'
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- ATTRIBUTES: generic key/value pairs used for access rules or filtering.
CREATE TABLE IF NOT EXISTS attributes (
    attr_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    attribute_key TEXT NOT NULL,
    attribute_value TEXT NOT NULL
);

-- CHANNELS: a communication stream. Optional JSONB metadata for flexible fields.
CREATE TABLE IF NOT EXISTS channels (
    channel_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    metadata JSONB
);

-- Ensure channel names are unique so we don't accidentally create duplicates.
CREATE UNIQUE INDEX IF NOT EXISTS ux_channels_name ON channels (name);

-- USER <-> ATTRIBUTES: many-to-many join table linking users to attributes.
-- ON DELETE CASCADE ensures related links are removed if a user/attribute is deleted.
CREATE TABLE IF NOT EXISTS user_attributes (
    user_id INT REFERENCES users(user_id) ON DELETE CASCADE,
    attr_id INT REFERENCES attributes(attr_id) ON DELETE CASCADE,
    PRIMARY KEY (user_id, attr_id)
);

-- CHANNEL <-> REQUIRED ATTRIBUTES: which attributes are required to access a channel.
CREATE TABLE IF NOT EXISTS channel_attributes (
    channel_id INT REFERENCES channels(channel_id) ON DELETE CASCADE,
    attr_id INT REFERENCES attributes(attr_id) ON DELETE CASCADE,
    PRIMARY KEY (channel_id, attr_id)
);

-- SUBSCRIPTIONS: which users subscribe to which channels and with what permission.
CREATE TABLE IF NOT EXISTS channel_subscriptions (
    subscription_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id INT REFERENCES users(user_id) ON DELETE CASCADE,
    channel_id INT REFERENCES channels(channel_id) ON DELETE CASCADE,
    permission permission_enum NOT NULL,
    notifications_enabled BOOLEAN NOT NULL DEFAULT TRUE
);

-- MESSAGES: content posted in channels. If a user is deleted, keep the message
-- but null the sender reference (ON DELETE SET NULL) to preserve history.
CREATE TABLE IF NOT EXISTS messages (
    message_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    channel_id INT REFERENCES channels(channel_id) ON DELETE CASCADE,
    sender_id INT REFERENCES users(user_id) ON DELETE SET NULL,
    message TEXT,
    attachment_url TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- MENTORS: mentor profile for a given user with eligibility data as JSONB.
CREATE TABLE IF NOT EXISTS mentors (
    mentor_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id INT REFERENCES users(user_id) ON DELETE CASCADE,
    mentorship_preferences TEXT,
    rank TEXT,
    years_of_service INT CHECK (years_of_service IS NULL OR years_of_service >= 0),
    eligibility_data JSONB,
    status mentor_status_enum NOT NULL DEFAULT 'requested'
);

-- MENTORSHIP REQUESTS: requests made by users, stored for later matching.
CREATE TABLE IF NOT EXISTS mentor_matching_requests (
    request_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id INT REFERENCES users(user_id) ON DELETE CASCADE,
    request_preferences TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- MENTORSHIP MATCHES: record pairings between requestors and mentors.
-- The UNIQUE constraint prevents duplicate pairings for the same two users.
CREATE TABLE IF NOT EXISTS mentorship_matches (
    match_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    requestor_user_id INT REFERENCES users(user_id),
    mentor_user_id INT REFERENCES users(user_id),
    matched_at TIMESTAMP NOT NULL DEFAULT NOW(),
    UNIQUE (requestor_user_id, mentor_user_id)
);

-- Foreign key indexes: indexing referenced columns speeds up joins and deletes.
CREATE INDEX IF NOT EXISTS ix_user_attributes_user_id ON user_attributes(user_id);
CREATE INDEX IF NOT EXISTS ix_user_attributes_attr_id ON user_attributes(attr_id);
CREATE INDEX IF NOT EXISTS ix_channel_attributes_channel_id ON channel_attributes(channel_id);
CREATE INDEX IF NOT EXISTS ix_channel_attributes_attr_id ON channel_attributes(attr_id);
CREATE INDEX IF NOT EXISTS ix_channel_subscriptions_user_id ON channel_subscriptions(user_id);
CREATE INDEX IF NOT EXISTS ix_channel_subscriptions_channel_id ON channel_subscriptions(channel_id);
CREATE INDEX IF NOT EXISTS ix_messages_channel_id ON messages(channel_id);
CREATE INDEX IF NOT EXISTS ix_messages_sender_id ON messages(sender_id);
CREATE INDEX IF NOT EXISTS ix_mentors_user_id ON mentors(user_id);
CREATE INDEX IF NOT EXISTS ix_mentor_matching_requests_user_id ON mentor_matching_requests(user_id);
CREATE INDEX IF NOT EXISTS ix_mentorship_matches_requestor_user_id ON mentorship_matches(requestor_user_id);
CREATE INDEX IF NOT EXISTS ix_mentorship_matches_mentor_user_id ON mentorship_matches(mentor_user_id);

-- Trigger function: automatically updates the "updated_at" timestamp on row updates.
CREATE OR REPLACE FUNCTION set_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Attach the trigger to any table that has an "updated_at" column.
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_trigger WHERE tgname = 'trg_users_set_updated_at'
    ) THEN
        CREATE TRIGGER trg_users_set_updated_at
        BEFORE UPDATE ON users
        FOR EACH ROW
        EXECUTE FUNCTION set_updated_at();
    END IF;
END$$;

COMMIT;


